{%

#include <time.h>
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <errno.h>
#include <netdb.h>
#include <unistd.h>

#ifndef HTTPSERVER_H
#include "http_parser.h"
#include "varray.h"
#include "http_server.h"
#include "http_response.h"
#include "http_request.h"
#define FIBER_IMPL
#include "fiber.h"
#endif

#define BUF_SIZE 1024

#define ACTIVE 0x1
#define READY 0x2

#define FLAG_SET(var, flag) var |= flag
#define FLAG_CLEAR(var, flag) var &= ~flag
#define FLAG_CHECK(var, flag) (var & flag)

varray_defn(http_token_t)

fiber_defn(http_server_listen, http_server_t*);
fiber_defn(http_session, http_request_t*);

void accept_connections(http_server_t* arg) {
  while (errno != EWOULDBLOCK) {
    int sock = accept(arg->socket, (struct sockaddr *)&arg->addr, &arg->len);
    if (sock > 0) {
      http_request_t* session = malloc(sizeof(http_request_t));
      *session = (http_request_t) { .socket = sock, .server = arg };
      int flags = fcntl(sock, F_GETFL, 0);
      fcntl(sock, F_SETFL, flags | O_NONBLOCK);
      fiber_spawn(http_session, session, session->fiber);
    }
  }
  errno = 0;
}

void bind_localhost(int s, struct sockaddr_in* addr, int port) {
  addr->sin_family = AF_INET;
  addr->sin_addr.s_addr = INADDR_ANY;
  addr->sin_port = htons(port);
  int rc = bind(s, (struct sockaddr *)addr, sizeof(struct sockaddr_in));;
  if (rc < 0) {
    exit(1);
  }
}

void http_listen(http_server_t* serv) {
  serv->socket = socket(AF_INET, SOCK_STREAM, 0);
  bind_localhost(serv->socket, &serv->addr, serv->port);
  serv->len = sizeof(serv->addr);
  listen(serv->socket, 128);
}

void read_client_socket(http_request_t* session) {
  int bytes;
  do {
    bytes = read(
      session->socket,
      session->buf + session->bytes,
      session->capacity - session->bytes
    );
    if (bytes > 0) {
      session->bytes += bytes;
      FLAG_SET(session->flags, READY);
    }
    if (session->bytes == session->capacity) {
      session->capacity *= 2;
      session->buf = realloc(session->buf, session->capacity);
    }
  } while (bytes > 0);
  if (bytes == 0) FLAG_CLEAR(session->flags, ACTIVE);
}

void write_client_socket(http_request_t* session) {
  session->bytes += write(session->socket, session->buf + session->bytes, session->capacity);
}

void nop(http_request_t* session) { }

void free_buffer(http_request_t* session) {
  free(session->buf);
  free(session->tokens.buf);
}

void end_session(http_request_t* session) {
  close(session->socket);
  free(session);
}

void parse_tokens(http_request_t* session) {
  static char const * names[] = { "METHOD", "TARGET", "VERSION", "HEADER_KEY", "HEADER_VALUE", "HEADER_END", "NONE", "BODY" };
  http_token_t token;
  do {
    token = http_parse(&session->parser, session->buf, session->bytes);
    if (token.type != HTTP_NONE) {
      session->token = token;
      varray_push(http_token_t, &session->tokens, token);
    }
    //printf("%s: %.*s\n", names[token.type], token.len, session->buf + token.index);
  } while (token.type != HTTP_NONE);
  FLAG_CLEAR(session->flags, READY);
}

void init_session(http_request_t* session) {
  session->flags |= HTTP_RESPONSE_KEEP_ALIVE;
  session->parser = (http_parser_t){ };
  session->bytes = 0;
  session->buf = NULL;
  session->token = (http_token_t){ .type = HTTP_NONE };
  session->tokens.size = 0;
  session->buf = malloc(BUF_SIZE);
  session->capacity = BUF_SIZE;
  varray_init(http_token_t, &session->tokens, 32);
}

void handle_timeout(http_request_t* request) {
  if (fibererror) {
    FLAG_CLEAR(request->flags, ACTIVE);
    fibererror = 0;
  }
}

int parsing_headers(http_request_t* request) {
  return request->token.type != HTTP_BODY && FLAG_CHECK(request->flags, ACTIVE);
}

int reading_body(http_request_t* request) {
  int size = request->token.index + request->token.len;
  return request->bytes < size && FLAG_CHECK(request->flags, ACTIVE);
}

%}

coroutine (await_t) http_server_listen(http_server_t*) {
  http_listen;
  while {% 1 %} {
    yield {% fiber_await(arg->socket, EV_READ, -1.f); %}; //wait for accept readability
    accept_connections;
  }
}

coroutine (await_t) http_session(http_request_t*) {
  {% FLAG_SET(arg->flags, ACTIVE); %}
  while {% FLAG_CHECK(arg->flags, ACTIVE) %} {
    init_session;
    read_client_socket;
    parse_tokens;
    while parsing_headers {
      //TODO if bytes read == 0 free buffers before yield
      yield {% fiber_await(arg->socket, EV_READ, 20.f); %}; //await readability
      handle_timeout;
      read_client_socket;
      parse_tokens;
    }
    if {% arg->token.len > 0 %} {
      read_client_socket;
      while reading_body {
        yield {% fiber_await(arg->socket, EV_READ, 20.f); %}; //await readability
        handle_timeout;
        read_client_socket;
      }
    }
    if {% FLAG_CHECK(arg->flags, ACTIVE) %} {
      {% arg->server->request_handler(arg); %}
      if {% !FLAG_CHECK(arg->flags, HTTP_RESPONSE_READY) %} {
        {% FLAG_SET(arg->flags, HTTP_RESPONSE_PAUSED); %}
        yield {% fiber_pause(); %};
        nop;
      }
      write_client_socket;
      while {% arg->bytes != arg->capacity %} {
        yield {% fiber_await(arg->socket, EV_WRITE, 20.f); %}; //await writeability
        handle_timeout;
        write_client_socket;
      }
    }
    free_buffer;
  }
  end_session;
}

{%

void generate_date_time(char** datetime) {
  time_t rawtime;
  struct tm * timeinfo;
  time(&rawtime);
  timeinfo = localtime(&rawtime);
  *datetime = asctime(timeinfo);
}

void date_generator(EV_P_ ev_timer *w, int revents) {
  generate_date_time((char**)w->data);
  ev_timer_again(fiber_scheduler, w);
}

void http_server_init(http_server_t* serv, int port, void (*handler)(http_request_t*)) {
  fiber_scheduler_init();
  serv->port = port;
  ev_init(&serv->timer, date_generator);
  serv->timer.data = (void*)&serv->date;
  serv->timer.repeat = 1.f;
  ev_timer_again(fiber_scheduler, &serv->timer);
  generate_date_time(&serv->date);
  serv->request_handler = handler;
}

int http_server_listen(http_server_t* serv) {
  fiber_spawn(http_server_listen, serv);
  fiber_scheduler_run();
  return 0;
}

struct ev_loop* http_server_loop() {
  return fiber_scheduler;
}

%}
